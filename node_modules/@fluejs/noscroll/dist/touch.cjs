'use strict';

const constants = require('./shared/noscroll.051b1d91.cjs');

const TOUCH_DETECTION_OFFSET = 3;
const touchState = {
  isPageScrollDisabled: false,
  startTouchY: 0,
  startTouchX: 0
};
const querySelectorClosestParent = (fromTarget, selector, matchSelf = true, rootTarget = document) => {
  let current = matchSelf ? fromTarget : fromTarget.parentElement;
  while (current && current !== rootTarget) {
    if (current.matches(selector)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
};
const isScrollableInput = (target) => {
  const selector = 'textarea, [contenteditable="true"]';
  return target.matches(selector);
};
const isInputRage = (target) => {
  const selector = 'input[type="range"]';
  return target.matches(selector);
};
const hasOverflowHidden = (target) => {
  const computedStyle = getComputedStyle(target);
  return computedStyle.overflow === "hidden";
};
const isAtScrollTop = (target) => {
  if (hasOverflowHidden(target)) {
    return true;
  }
  const scrollTop = target.scrollTop;
  return scrollTop <= 0;
};
const isAtScrollBottom = (target) => {
  if (hasOverflowHidden(target)) {
    return true;
  }
  const scrollTop = target.scrollTop;
  const scrollHeight = target.scrollHeight;
  const scrollTopWithHeight = scrollTop + target.offsetHeight;
  return scrollTopWithHeight >= scrollHeight;
};
const isAtScrollLeft = (target) => {
  if (hasOverflowHidden(target)) {
    return true;
  }
  const scrollLeft = target.scrollLeft;
  return scrollLeft <= 0;
};
const isAtScrollRight = (target) => {
  if (hasOverflowHidden(target)) {
    return true;
  }
  const scrollLeft = target.scrollLeft;
  const scrollWidth = target.scrollWidth;
  const scrollLeftWithWidth = scrollLeft + target.offsetWidth;
  return scrollLeftWithWidth >= scrollWidth;
};
const onTouchStart = (e) => {
  touchState.isPageScrollDisabled = document.body.matches(constants.attrAsSelector(constants.NoScrollAttrs.SCROLL_DISABLED));
  touchState.startTouchY = e.touches[0].clientY;
  touchState.startTouchX = e.touches[0].clientX;
};
const onTouchMove = (e) => {
  if (!touchState.isPageScrollDisabled) {
    return;
  }
  if (e.touches.length > 2) {
    return;
  }
  const { startTouchY, startTouchX } = touchState;
  const currentClientY = e.touches[0].clientY;
  const currentClientX = e.touches[0].clientX;
  const direction = {
    isUp: startTouchY < currentClientY,
    isDown: startTouchY > currentClientY,
    isLeft: startTouchX < currentClientX,
    isRight: startTouchX > currentClientX
  };
  const directionWithOffset = {
    isUp: startTouchY + TOUCH_DETECTION_OFFSET < currentClientY,
    isDown: startTouchY - TOUCH_DETECTION_OFFSET > currentClientY,
    isLeft: startTouchX + TOUCH_DETECTION_OFFSET < currentClientX,
    isRight: startTouchX - TOUCH_DETECTION_OFFSET > currentClientX
  };
  const handle = (el, skip = false) => {
    if (!el) {
      if (e.cancelable) {
        e.preventDefault();
      }
      return;
    }
    if (isInputRage(el)) {
      return;
    }
    const scrollableParent = querySelectorClosestParent(
      el,
      constants.attrAsSelector(constants.NoScrollAttrs.SCROLLABLE),
      false
    );
    if (!(skip || isScrollableInput(el) && querySelectorClosestParent(el, constants.attrAsSelector(constants.NoScrollAttrs.SCROLLABLE)) || el.matches(constants.attrAsSelector(constants.NoScrollAttrs.SCROLLABLE)))) {
      handle(scrollableParent);
      return;
    }
    let prevent = false;
    if (isAtScrollLeft(el) && isAtScrollRight(el)) {
      if (direction.isUp && isAtScrollTop(el) || direction.isDown && isAtScrollBottom(el)) {
        prevent = true;
      }
    } else if (isAtScrollTop(el) && isAtScrollBottom(el)) {
      if (direction.isLeft && isAtScrollLeft(el) || direction.isRight && isAtScrollRight(el)) {
        prevent = true;
      }
    } else if (directionWithOffset.isUp && isAtScrollTop(el) || directionWithOffset.isDown && isAtScrollBottom(el) || directionWithOffset.isLeft && isAtScrollLeft(el) || directionWithOffset.isRight && isAtScrollRight(el)) {
      prevent = true;
    }
    if (prevent) {
      if (scrollableParent) {
        handle(scrollableParent, true);
      } else if (e.cancelable) {
        e.preventDefault();
      }
    }
  };
  handle(e.target);
};
const onTouchEnd = () => {
  touchState.startTouchY = 0;
  touchState.startTouchX = 0;
};
const initTouchHandler = () => {
  document.addEventListener("touchstart", onTouchStart);
  document.addEventListener("touchmove", onTouchMove, {
    passive: false
  });
  document.addEventListener("touchend", onTouchEnd);
};
const resetTouchHandler = () => {
  document.removeEventListener("touchstart", onTouchStart);
  document.removeEventListener("touchmove", onTouchMove);
  document.removeEventListener("touchend", onTouchEnd);
};

exports.hasOverflowHidden = hasOverflowHidden;
exports.initTouchHandler = initTouchHandler;
exports.isAtScrollBottom = isAtScrollBottom;
exports.isAtScrollLeft = isAtScrollLeft;
exports.isAtScrollRight = isAtScrollRight;
exports.isAtScrollTop = isAtScrollTop;
exports.resetTouchHandler = resetTouchHandler;
